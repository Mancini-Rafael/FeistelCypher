exit
FeistelSwapper.new({bits: @bits_to_decrypt, key: ENV.fetch('KEY') }).swap
@bits_to_decrypt
c
ENV.fetch('KEY')
FeistelEncryptor.new({bits: "01100111"}).encrypt
@bits_to_decrypt
n
exit
FeistelSwapper.new({bits: first_result, key: ENV.fetch('KEY') }).swap
n
list =
ENV.fetch('KEY')
@bits_to_encrypt
FeistelSwapper.new({bits: @bits_to_encrypt, key: ENV.fetch('KEY') }).swap
c
(@right + new_right).join("")
@right + new_right
new_right
@right
@left.zip(crypted_portion)
new_right
n
c
@right
join_bits(crypted_portion)
n
c
join_bits(crypted_portion)
n
list =
@key.zip(@right)
run_function
@key
@right
@left
split_bits
c
@bits
@right
@left
split_bits
exit
run_function
@right
@left
split_bits
c
@key.zip(@right).map{ |kd, rd| kd ^ rd }
@key.zip(@right)
@key.zip(@rigth)
@key
run_function
@right
@left
split_bits
exit
@right
@left
split_bits
c
(@left + new_right).join("")
(@left + new_right).join(",")
@left + new_right
c
@left + new_right
@right
@left
c
@left
new_right
c
new_right << l.to_i ^ r.to_i
new_right
l.to_i ^ r.to_i
l.to_i
c
var l
c
l.to_i ^ r.to_i
list =
var l
r
l
c
@left.zip(crypted_portion)
@left
new_right
exit
@left
@right
@left
(@key.split("") + @left).map(&:to_i).map{ |l| l == 0 ? 1 : 0 }
(@key.split("") + @left).map(&:to_i).map{ |l| l }
(@key.split("") + @left).map(&:to_i).map{ |l| }
(@key.split("") + @left).map(&:to_i).map{ |l| !l }
@key.split("") + @left
@key.split("")
@key.to_a
@left
@lef
@key
c
n
c
params[:key].nil?
params
exit
ENV.fetch('KEY')
c
$stdout.gets
$stdout.rewind.gets
$stdout.rewind
